<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2353Devrecords</title>
    <link rel="stylesheet" href="/style/style.css" />
    <script src="/src/main.js" defer></script>
  </head>
  <body>
    <a name="top"></a>
    <header>
      <div class="top-box">
        <div class="top-left-box">
          <nav>
            <a href="/index.html">Home</a>
          </nav>
        </div>
        <div class="top-middle-box">
          <h1>TIL 2023</h1>
        </div>
        <div class="top-right-box"></div>
      </div>
      <hr class="line" />
    </header>
    <main>
      <div class="month-link">
        <a href="/pages/TIL2305.html">2305</a>
        <a href="/pages/TIL2306.html">2306</a>
        <a href="/pages/TIL2307.html">2307</a>
      </div>
      <div class="middle-content">
        <div class="date-link">
          <a href="#0701">0701</a>
          <a href="#0702">0702</a>
          <a href="#0703">0703</a>
          <a href="#0704">0704</a>
          <a href="#0705">0705</a>
          <a href="#0706">0706</a>
          <a href="#0707">0707</a>
          <a href="#0708">0708</a>
          <a href="#0709">0709</a>
          <a href="#0710">0710</a>
          <a href="#0711">0711</a>
          <a href="#0712">0712</a>
          <a href="#0713">0713</a>
        </div>
        <div class="content">
          <h1><a href="#top" name="0701">0701</a></h1>
          <div class="cnts">
            <h3>node.js</h3>
            multer
            <li>node.js에서 파일 업로드를 처리하기 위한 미들웨어</li>
            fs
            <li>
              node.js의 내장 모듈, 파일 시스템(file system)에 접근, 파일 생성,
              읽기, 쓰기, 삭제, 이동, 이름 변경
            </li>
            <h3>javascript</h3>
            ejs
            <li>Embedded JavaScript, javascript 기반의 템플릿 엔진</li>
          </div>
          <h1><a href="#top" name="0702">0702</a></h1>
          <div class="cnts">
            <h3>node.js</h3>
            라우터
            <li>
              라우터 모듈은 특정 URL 경로에 대한 요청을 처리하고 응답을 반환하는
              역할, 특정 API 엔드포인트를 정의
            </li>
            path
            <li>파일 경로를 다루기 위한 모듈</li>
            const { Op } = require('sequelize');
            <li>Op 객체를 통해 쿼리 작성에 사용하는 연산자에 접근</li>
          </div>
          <h1><a href="#top" name="0703">0703</a></h1>
          <div class="cnts">
            <h3>javascript</h3>
            이벤트 루프
            <li>비동기 작업을 처리하고 실행순서를 관리하는 매커니즘</li>
            실행 컨텍스트
            <li>코드가 실행되는 환경을 제공하는 객체</li>
            <li>호이스팅</li>
            <li>LE, record, outer</li>
            <li>컴파일러/인터프리터</li>
            <li>
              일시적 사각지대(Temporal Dead Zone): 선언 이전에 식별자를 참조할
              수 없는 구역
            </li>
            <li>
              스코프 체인(Scope Chain): 식별자를 결정할 때 활용하는 스코프들의
              연결리스트
            </li>
            <li>
              스코프 체이닝(Scope Chaining): 식별자를 결정하기 위해 하는 과정
              자체
            </li>
            클로저
            <li>자신이 선언될 당시의 환경을 기억하는 함수</li>
            <li>스코프: 변수에 접근할 수 있는 범위</li>
            <li>함수는 힙 메모리에 저장</li>
            <li>
              객체 지향 프로그램의 정보 은닉과 캡슐과 같은 효과를 얻을 수 있음
            </li>
            Promise
            <li>콜백 지옥에서 벗어나기</li>
            <li>비동기 처리의 결과를 약속하는 객체</li>
            <li>상태값: pending, fulfilled(성공), rejected(실패)</li>
            <li>성공 => resolve(), 실패 => reject()</li>
            <li>.then, .catch 체이닝</li>
            async, await
            <li>함수가 끝날 때까지 기다린다</li>
            class
            <li>생성자 constructor</li>
            <li>메서드 method()</li>
            <li>
              class 자식 extends 부모: 자식 클래스는 부모 클래스의 메서드 사용
              가능, 반대는 불가능
            </li>
            array
            <li>
              중간에 넣거나 빼기 속도 아주 느림, 메모리 공간 주소 할당, 빈 칸
              생기면 채우는 과정 복잡
            </li>
            <li>만들기(split): 문자열을 배열로</li>
            <li>합치기(join): 배열을 문자열로</li>
            <li>추가(push)</li>
            <li>배열 합치기(concat): const array3 = array1.concat(array2);</li>
            <li>삭제(pop, splice: 원본 배열 바꿈, slice: 새로운 함수 반환)</li>
            <li>반복문(forEach, map: 새로운 배열 반환, 객체 반환 가능)</li>
            <li>
              찾기(find: 객체 검색 가능, indexOf: 없으면 -1, findIndex: 없으면
              -1, includes)
            </li>
            <li>
              정렬(sort: 원본 배열을 바꿈, 콜백함수 없으면 유니코드 기준으로
              정렬)
            </li>
            <li>뒤집기(reverse)</li>
            Map
            <li>객체와 비슷, 객체는 key에 string만 씀</li>
            <li>쓰는 이유? 명시적이다. get, set, has, clear</li>
            <li>객체와 맵은 서로 호환이 된다.</li>
            <li>let map1 = new Map(); map1.set('a', 3); map1.get('a');</li>
            <li>key찾기: map1.has('a')</li>
            <li>내용 지우기: map1.clear();</li>
            Set
            <li>중복을 허용 하지 않음, 키가 없음</li>
            <li>const set1 = new Set(); set1.add(1); set1.has(1);</li>
          </div>
          <h1><a href="#top" name="0704">0704</a></h1>
          <div class="cnts">
            <h3>http</h3>
            TCP
            <li>
              서버와 클라이언트간 신뢰성 있는 데이터 송수신을 위해 만들어진
              프로토콜
            </li>
            UDP
            <li>TCP와 다르게 비연결성 프로토콜</li>
            소켓
            <li>네트워크에서 데이터를 송수신하기 위해 반드시 거치는 연결부</li>
            <li>
              TCP 소켓: 안정적인 데이터 송수신, UDP 소켓: 빠른 전송속도, 일부
              패킷 손실 가능
            </li>
            패킷
            <li>소켓을 통해 송수신하는 데이터 덩어리 한 개</li>
            웹소켓
            <li>실시간 웹 서비스를 제공하기 위해 만들어진 Socket</li>
            <li>Google Docs 등 협업툴의 실시간 공동 편집 기능, 웹 메신저</li>
            socket.io
            <li>
              자바스크립트를 사용해 웹소켓 사용할 때 가장 많이 사용되는
              라이브러리
            </li>
            <li>
              웹소켓을 포함해 웹소켓을 사용하지 못 하는 브라우저에서 사용
              가능하게 구현
            </li>
            <h3>html</h3>
            <li>html 파일 브라우저에 드래그, 드랍</li>
            <h3>cookie</h3>
            <li>refresh token 저장할 object 전역변수</li>
            <li>
              jwt.sign으로 access token(jwt 데이터에 유저 정보 저장: 서버에
              접근할 때 확인용), refresh token 생성(서버에서 인증받은 사용자가
              맞는지 검증용)
            </li>
            <li>refresh token에 유저 정보 저장</li>
            <li>각 토큰 쿠키에 전달</li>
            <li>쿠키에 있는 각 토큰 변수에 담아서 검증 시작</li>
            <li>
              토큰의 존재 유무, jwt.verify 검증(refresh token 없으면 만료,
              access token 없으면 refresh token 재발급)
            </li>
            <li>access token에 유저 정보 없으면 access token 새로 발급</li>
            <li>
              tokenObject[refreshToken] = id; refreshToken의 값이 key, id 값이
              value인 객체 tokenObject
            </li>
            <h3>redis</h3>
            <li>인메모리 데이터 저장소</li>
            <li>
              캐시는 데이터 미리 계산하여 저장, 필요할 때 저장된 데이터 바로
              제공
            </li>
            <li>빠른 응답, DB에 비해 높은 처리량</li>
            <h3>OSI 7계층</h3>
            <li>
              Open Systems Interconnection 7 layer, 네트워크 통신이 일어나는
              과정 7단계
            </li>
            <li>물리 physical: 리피터, 허브, 광케이블</li>
            <li>데이터링크 Data Link: MPLS, Ethernet</li>
            <li>네트워크 Network: IP</li>
            <li>전송 Transport: TCP, UDP</li>
            <li>세션 Session: 통신하는 프로세스/호스트간 연결 유지 SSL, TLS</li>
            <li>표현 presentation: 데이터 포맷</li>
            <li>어플리케이션 Application: HTTP</li>
          </div>
          <h1><a href="#top" name="0705">0705</a></h1>
          <div class="cnts">
            <h3>transaction</h3>
            <li>작업의 완전성 보장, 그룹화</li>
            <li>특정 작업 전부 처리, 전부 실패, 데이터의 일관성 보장</li>
            <li>partial update 방지</li>
            <li>
              ACID 데이터 베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기
              위한 특징
            </li>
            <li>Atomicity 원자성: 여러 작업 묶음</li>
            <li>
              Consistency 일관성: 성공시 문제 발생하지 않고 실패시 데이터 유지
            </li>
            <li>
              Isolation 격리성: 중간 상태의 트랜잭션 보거나 변경할 수 없게 구성
              lock
            </li>
            <li>Durability 지속성: 완성된 결과만 저장</li>
            <h3>lock</h3>
            <li>
              동시성 제어, 데이터 베이스 점유해서 다른 트랜잭션의 접근 막아
              동시성과 일관석의 균형 맞추기
            </li>
            <li>shared locks 공유 락, 읽기 허용/수정 금지, read 전용 락</li>
            <li>exclusive locks 배타락, 읽기,수정 금지, write 전용 락</li>
            <h3>locking level</h3>
            <li>
              global locks 데이터 베이스의 모든 테이블 락(현재 트랜잭션만 사용)
            </li>
            <li>table locks 테이블 동시 수정 불가</li>
            <li>named locks 특정 문자열 점유(금지)</li>
            <li>
              metadata locks 동일한 행 및 데이터 베이스의 객체 동시 수정 금지
            </li>
            <h3>잘못된 lock 설정</h3>
            <li>
              모든 API 동작 중지되는 교착상태(dead lock) 발생, 프로그램 멈춤
            </li>
            <li>
              dead lock여러 테이블 락, 다른 작업 처리 못 하게 점유, 다른 작업
              끝나기를 무한정 기다림(서로가 서로의 리소르 점유)
            </li>
            <h3>isolation level 트랜잭션의 격리 수준</h3>
            <li>동시 처리될 때 다른 트랜잭션에 대한 행위 허용/거부 결정</li>
            <li>
              read uncommited 커밋 되지 않은 읽기 허용(작업중인 데이터 읽음)
            </li>
            <li>read commited 커밋된 읽기만 허용</li>
            <li>
              repeteable 트랜잭션이 완전히 종료될 때가지 락 유지, 데이터 수정
              불가능/삽입 가능 -> 팬텀 읽기 발생(phantom row=삭제된 데이터)
            </li>
            <li>
              serializable 데이터를 읽는 동안 다른 트랜잭션이 읽기/삽입/추가
              불가, 가장 높은 수준의 격리 수준, 동시성 떨어짐
            </li>
            <h3>transaction 흐름</h3>
            <li>트랜잭션 객체 할당</li>
            <li>할당된 객체 각각의 쿼리에 할당</li>
            <li>모든 로직 완료 되었을 때 commit</li>
            <li>작업 실패했을 때 rollback</li>
            <li>sequelize에서 Transaction 객체 구조 분해 할당</li>
            <li>격리 수준 설정</li>
            <h3>UsersHistories</h3>
            <li>
              사용자의 이름을 변경하는 api 구현, 변경된 사용자 이름 정보 logging
              하기 위해
            </li>
            <li>
              사용자의 모든 변경사항, api 호출 내역 등 다양한 정보를 저장하게
              된다면 UUID 사용해 컬럼을 최소화
            </li>
            <h3>Object-Oriented 객체 지향</h3>
            <li>누가 어떤 역할을 할 것인가?</li>
            <li>
              객체지향: 캡슐화, 다형성, 클래스 상속 지원, 데이터 접근
              제한<->절차지향
            </li>
            <li>
              캡슐화 Encapsulation: 정보 은닉, 변경하기 쉬운 객체, 객체와 객체
              사이의 결합도 낮춤
            </li>
            <li>
              상속 Inheritance: 코드 중복 제거, 재사용성 증대, 체계화된 구조
              파악 쉬움, 부모클래스만 수정해 일관성 유지
            </li>
            <li>
              추상화 Abstraction: 객체에서 공통된 특성 파악, 불필요한 부분 제거
            </li>
            <li>
              다형성 Polymorphism: 동일한 메소드 이름, 클래스마다 다르게 구현
            </li>
            <li>
              의존성 Dependency: 어떤 객체가 변경될 때 그 객체에 의존하는 다른
              객체도 함께 변경될 수 있음
            </li>
            <li>결합도 Coupling: 의존성의 정도, 결합도가 높다/낮다</li>
            <li>
              응집도 Cohesion: 자신의 데이터 스스로 처리하는 자율적인 객체는
              응집도 높음
            </li>
            <li>
              목표: 추상화->추상 클래스->인터페이스->다형성, 의존성↓ 결합도↓
              응집도↑
            </li>
            <li>
              클래스의 멤버 변수는 외부에서 직접 접근 불가능, setter/getter로
              변경/조회 가능
            </li>
            <li>
              typescript: javascript는 클래스 멤버 변수 숨길 수 없음, 인터페이스
              없음
            </li>
            <li>
              overriding 오버라이딩: 부모클래스 생성 메서드 -> 자식클래스에서
              새로 생성
            </li>
            <li>
              overloading 오버로딩: 부모클래스 생성 메서드 -> 자식클래스
              파라미터 다르게 새로 생성
            </li>
            <h3>프로그래밍 패러다임</h3>
            구조적 프로그래밍 Structured Programming
            <li>기능 중심 개발, 제어 흐름의 직접적인 전환에 대한 규칙 제시</li>
            객체 지향 프로그래밍 Object-Oriented Programming
            <li>
              현실 세계를 모델링, 제어 흐름의 간접적인 전환에 대한 규칙 제시
            </li>
            <li>데이터, 프로세스가 동일한 모듈 내부에 위치</li>
            <li>최소한의 수정, 개발 시간 최소화</li>
            <li>
              데이터 중심으로 프로그래밍, 덩치는 커져도 일관성 유지하기 좋음
            </li>
            함수형 프로그래밍 Functional Programming
            <li>함수를 중심적으로 개발, 할당문에 대한 규칙 제시</li>
            객체 지향 설계
            <li>
              요구 기능 온전히 수행, 이해하기 쉬운 코드, 변경하기 쉬운 설계(한
              번에 하나의 클래스만 변경)
            </li>
            <li>캡슐화 -> 의존성 적절히 관리 -> 객체 사이의 결합도 낮춤</li>
            <h3>객체 지향 설계 5원칙 SOLID</h3>
            <li>유지 보수, 확장 쉬운 시스템 만들 때 사용</li>
            SRP 단일 책임의 원칙 Single Responsibility Principle
            <li>적절한 클래스의 크기 제시, 동작하기만 하는 소프트웨어 X</li>
            OCP 개방-폐쇄 원칙 Open-Closed Principle
            <li>
              개체의 행위는 확장, 개체 변경은 안됨 (기존 코드 영향 없이 새로운
              기능, 구성요소 추가 가능)
            </li>
            LSP 리스코프 치환 원칙 Liskov substitution principle
            <li>부모클래스와 자식클래스를 서로 바꿔도 동일한 결과값 도출</li>
            ISP 인터페이스 분리 원칙 Interface segregation principle
            <li>
              사용자가 필요하지 않은 것들에 의존하지 않도록 인터페이스 작게 유지
            </li>
            DIP 의존성 역전 원칙 Dependency Inversion Principle
            <li>
              높은 계층의 모듈은 낮은 계층의 모듈에 의존해선 안됨, 추상화에
              의존해야지 구체화에 의존하면 안 된다
            </li>
          </div>
          <h1><a href="#top" name="0706">0706</a></h1>
          <div class="cnts">
            <h3>Layered Architecture Pattern</h3>
            <li>domain: 개발자가 만든 프로세스가 지원하는 활동</li>
            <li>domain model: 특정 도메인 개념적으로 정리</li>
            <li>domain modeling: entity, value object, domain service</li>
            Layered Architecture 플로우
            <li>클라이언트가 요청 보냄</li>
            <li>요청을 url에 맞는 컨트롤러가 수신</li>
            <li>컨트롤러는 요청을 처리하기 위해 서비스 호출</li>
            <li>서비스는 필요한 데이터를 가져오기 위해 저장소에 데이터 요청</li>
            <li>서비스는 저장소에서 가져온 데이터 가공, 컨트롤러에게 넘김</li>
            <li>컨트롤러는 서비스의 결과물 클라이언트에 전달</li>
            <h3>review</h3>
            스레드
            <li>
              싱글 스레드: 한 번에 하나의 작업만 처리, 대부분의 웹 브라우저 환경
            </li>
            <li>
              멀티 스레드: 다수의 작업을 동시에 처리, 대규모 데이터 처리, 동시
              접속 처리하는 서버
            </li>
            동기/비동기, 블로킹/논블로킹
            <li>
              동기: 작업이 끝날 때까지 다음 작업이 실행되지 않고 순차적으로
              진행됨
            </li>
            <li>
              비동기: 작업이 실행되는 동안 다른 작업을 동시에 수행, 콜백함수,
              프로미스, async/await
            </li>
            <li>블로킹: 한 작업이 끝날 때까지 다음 작업을 중지</li>
            <li>논블로킹: 작업이 실행되는 동안 다른 작업을 계속 실행</li>
            jsvascript 내장 모듈
            <li>os: 운영체제와 관련된 정보 제공</li>
            <li>
              cluster: 멀티 스레딩 지원, 서버 애플리케이션 여러 개의 프로세스로
              나누어 처리, 각 프로세스는 독립적 요청 처리
            </li>
            <li>path: 파일 경로, 이름, 확장자 추출</li>
            <li>fs: 파일 생성, 삭제, 읽기, 쓰기</li>
            <li>http: 서버/클라이언트 생성/관리</li>
            인증/인가
            <li>인증: Authentication 신원 확인</li>
            <li>인가: Authorization 접근 권한 부여</li>
            쿠키/세션/jwt
            <li>
              쿠키: 브라우저에 저장되는 사용자 식별 정보, 간단한 사용자
              정보/상태 유지하고 식별할 때
            </li>
            <li>
              세션: 서버에 저장되는 사용자 정보를 세션 id로 관리, 중요한 사용자
              정보를 안전하게 관리하고 인증 상태를 유지해햐 할 때
            </li>
            <li>
              jwt: 클라이언트와 서버 간에 인증을 위한 정보를 안전하게 전송하기
              위한 토큰 기반 인증 방식, 세션 관리 대체
            </li>
            미들웨어
            <li>
              역할: 클라이언트로부터 들어온 요청을 파싱, 인증, 데이터 검증,
              응답처리
            </li>
            <li>
              사용 방법: 애플리케이션 미들웨어 app.use(), 라우터 미들웨어
              router.use(), 에러 처리 미들웨어에 에러 핸들러 함수 등록
            </li>
            orm
            <li>
              object relational mapping, 객체 지향 프로그래밍 언어와 관계형
              데이터베이스 간의 매핑
            </li>
            sequelize
            <li>npx sequelize init, db:create</li>
            <li>
              model:generate --name User --attributes
              username:string,password:string
            </li>
            <li>db:migrate</li>
          </div>
          <h1><a href="#top" name="0707">0707</a></h1>
          <div class="cnts">
            <h3>sequelize</h3>
            Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are
            sent to the client
            <li>return을 안 하고 응답을 두 번 함</li>
            Error: Argument passed to findByPk is invalid: [object Object]
            <li>
              전달된 인수가 올바르지 않음 { userId }가 아니라 userId를 전달해야
              함
            </li>
            original: Error: Unknown column 'userId' in 'field list'
            <li>userId 컬럼을 찾을 수 없음. model에 userid로 쓰여있었음</li>
            Validation error, PRIMARY must be unique
            <li>
              await queryInterface.renameColumn("users", "userid", "userId");
            </li>
            <li>
              column 이름을 userid 에서 userId로 바꿨는데 attributes에서
              autoincrement가 해제됨
            </li>
            ERROR: Multiple primary key defined
            <li>프라이머리 키 둘 이상</li>
            ERROR: Cannot read properties of undefined (reading 'toString')
            <li>changecolumn에서 autoincrement만 migrate 하려고 함</li>
            <li>type: Sequelize.INTEGER, 칼럼 타입 명시해줘야 함</li>
            autoIncrement
            <li>새로운 컬럼 생성할 때마다 만들어 줘야함</li>
            <h3>http status</h3>
            200
            <li>OK, 로그인 성공, 사용자/게시글/상세 조회, 게시글 수정/삭제</li>
            201
            <li>Created, 회원가입 완료, 게시글 생성</li>
            400
            <li>Bad Request, 잘못된 요청</li>
            401
            <li>
              Unauthorized, 미승인/비인증, 존재하지 않는 이메일/토큰 사용자,
              비밀번호/토큰 타입 일치하지 않아, 비정상적인 요청, 권한이 없어
            </li>
            404
            <li>Not Found 게시글이 존재하지 않아</li>
            409
            <li>
              Conflict, 요청이 현재 서버 상태와 충돌, 이미 존재하는 이메일
            </li>
          </div>
          <h1><a href="#top" name="0708">0708</a></h1>
          <div class="cnts">
            <h3>error</h3>
            sequelize validation error
            <li>changeColumn 하면서 autoIncrement 추가하려는데 오류남</li>
            <li>다른 속성 하나씩 넣고 빼보면서 다양한 새로운 오류만 발견</li>
            <li>구글에선 같은 상황 찾지 못 함</li>
            <li>
              chat gpt가 답해준 "이미 존재하는 데이터"의 의미를 뒤늦게 생각
            </li>
            <li>데이터 베이스에 userId 값이 0인 데이터가 있어서 생긴 오류</li>
            <li>해당 컬럼 지우기</li>
            <li>
              <span class="unknown"
                >문제의 시작점: renameColumn 하면서 autoIncrement 사라짐</span
              >
            </li>
            <li>
              <span class="add"
                >renameColumn 할 때 changeColumn 같이 하면서 autoIncrement
                추가하기</span
              >
            </li>
          </div>
          <h1><a href="#top" name="0709">0709</a></h1>
          <div class="cnts">
            <h3>javascript</h3>
            <li>메서드는 보통 대상.메서드(요소) 로 쓴다</li>
            charAt과 at의 차이
            <li>at: 최신/비표준/음수 지원</li>
            <li>charAt: 표준/안정적</li>
            for ... of와 forEach의 차이
            <li>for ... of: 반복 가능 객체, break, 반환 가능</li>
            <li>forEach: 배열, 인덱스 접근</li>
            <h3>sequelize</h3>
            <li>
              <span class="unknown"
                >migration 할 때 데이터 베이스에 데이터가 있어서 migration이 안
                될 때가 자주 있는데 이러 땐 어떻게 할까?</span
              >
            </li>
            <h3>error</h3>
            "message": "notNull Violation: Post.title cannot be null,\nnotNull
            Violation: Post.content cannot be null"
            <li>POST http://localhost:3000/posts/14/comments</li>
            <li>댓글 생성 api인데 Post.create로 작성</li>
            "message": "notNull Violation: Comment.commentId cannot be
            null,\nnotNull Violation: Comment.postId cannot be null,\nnotNull
            Violation: Comment.comment cannot be null"
            <li>api에서 Comment.create에 postId 안 씀</li>
            <li>api.rest에서 commnet 오타</li>
            <li>commentId는 autoIncrement인데 notNull 오류 생기는 이유?</li>
            <li>model에서 autoIncerment 오타, migration만 수정했었음</li>
            parent: Error: Unknown column 'poseId' in 'field list'
            <li>Commnet 모델에 foreignKey: "poseId", 오타</li>
            Error: WHERE parameter "username" has invalid "undefined" value
            <li>댓글 수정 api</li>
            <li>api.rest에 Content-Type: application/json 안 씀</li>
          </div>
          <h1><a href="#top" name="0710">0710</a></h1>
          <div class="cnts">
            <h3>error</h3>
            Cannot POST /signup
            <li>회원가입 api 첫 post, url에 /api 안 씀</li>
            notNull Violation: UserInfos.userId cannot be null
            <li>데이터 베이스 접근할 때 await 안 씀</li>
            Error: WHERE parameter "email" has invalid "undefined" value
            <li>
              로그인 api 시도, api.rest에 Content-Type: application/json 또 안
              적음
            </li>
            ReferenceError: user is not defined
            <li>
              console.log(user)의 출력 결과가 undefined가 아니라 user is not
              defined
            </li>
            <li>user 선언을 안 해줘서</li>
            if (!user || user.password !== password)
            <li>
              req.body 에서 password를 integer로 받아서 기존에 있던 string
              password와 불일치
            </li>
            jwt is not defined
            <li>require로 jsonwebtoken 안 가져옴</li>
          </div>
          <h1><a href="#top" name="0711">0711</a></h1>
          <div class="cnts">
            <h3>error</h3>
            jwt expired
            <li>jwt 만료됨</li>
            <li>
              payload에 exp: +10 추가하면 10초 후 로그아웃? 되는데 10초 안에도
              만료된 이상한 상태
            </li>
            <li>옵션 자리에 { expiresIn: "10s" } 추가하면 잘 됨</li>
            Users is associated to Posts using an alias. You must use the 'as'
            keyword to specify the alias within your include statement.
            <li>게시글 조회 여러 테이블 join</li>
            <li>
              게시글에서 include할 유저 테이블의 별명 user를 include에 같이 써야
              함
            </li>
            Error: Cannot find module '../middlewares'
            <li>유저 라우터 파일에 인증 미들웨어 불러왔더니 오류 발생</li>
            <li>
              const authMiddleware = require('../middlewares/auth-middleware');
            </li>
            <li>파일까지 불러와야 함</li>
            errorMessage: Argument passed to findByPk is invalid: [object
            Object]
            <li></li>
            TypeError: Router.use() requires a middleware function but got a
            Object
            <li>
              app.js 오류?, likes 라우터 만들면서 posts 라우터의 module.exports
              = router;를 지움
            </li>
            original: Error: Unknown column 'PostPostId' in 'field list'
            <li></li>
            <h3>weird</h3>
            <li>npx nodemon app.sj 잘못 적어도 잘 실행된다</li>
          </div>
          <h1><a href="#top" name="0712">0712</a></h1>
          <div class="cnts">
            <h3>sequelize</h3>
            fn
            <li>쿼리 메서드를 사용할 수 있게 하는 시퀄라이즈 함수</li>
            <li>
              attributes: [Sequelize.fn('메서드', Sequelize.clo('as.컬럼'),
              '새로운 컬럼')]
            </li>
            group
            <li>GROUP BY, 같은 컬럼 묶기, DISTINCT랑 다름(중복 제거)</li>
          </div>
          <h1><a href="#top" name="0713">0713</a></h1>
          <div class="cnts"></div>
        </div>
      </div>
      <div class="outer-link"></div>
    </main>
    <footer></footer>
  </body>
</html>
