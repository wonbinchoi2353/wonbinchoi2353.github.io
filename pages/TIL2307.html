<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2353Devrecords</title>
    <link rel="stylesheet" href="/style/style.css" />
    <script src="/src/main.js" defer></script>
  </head>
  <body>
    <a name="top"></a>
    <header>
      <div class="top-box">
        <div class="top-left-box">
          <nav>
            <a href="/index.html">Home</a>
          </nav>
        </div>
        <div class="top-middle-box">
          <h1>TIL 2023</h1>
        </div>
        <div class="top-right-box"></div>
      </div>
      <hr class="line" />
    </header>
    <main>
      <div class="month-link">
        <a href="/pages/TIL2305.html">2305</a>
        <a href="/pages/TIL2306.html">2306</a>
        <a href="/pages/TIL2307.html">2307</a>
      </div>
      <div class="middle-content">
        <div class="date-link">
          <a href="#0701">0701</a>
          <a href="#0702">0702</a>
          <a href="#0703">0703</a>
          <a href="#0704">0704</a>
          <a href="#0705">0705</a>
          <a href="#0706">0706</a>
        </div>
        <div class="content">
          <h1><a href="#top" name="0701">0701</a></h1>
          <div class="cnts">
            <h3>node.js</h3>
            multer
            <li>node.js에서 파일 업로드를 처리하기 위한 미들웨어</li>
            fs
            <li>
              node.js의 내장 모듈, 파일 시스템(file system)에 접근, 파일 생성,
              읽기, 쓰기, 삭제, 이동, 이름 변경
            </li>
            <h3>javascript</h3>
            ejs
            <li>Embedded JavaScript, javascript 기반의 템플릿 엔진</li>
          </div>
          <h1><a href="#top" name="0702">0702</a></h1>
          <div class="cnts">
            <h3>node.js</h3>
            라우터
            <li>
              라우터 모듈은 특정 URL 경로에 대한 요청을 처리하고 응답을 반환하는
              역할, 특정 API 엔드포인트를 정의
            </li>
            path
            <li>파일 경로를 다루기 위한 모듈</li>
            const { Op } = require('sequelize');
            <li>Op 객체를 통해 쿼리 작성에 사용하는 연산자에 접근</li>
          </div>
          <h1><a href="#top" name="0703">0703</a></h1>
          <div class="cnts">
            <h3>javascript</h3>
            이벤트 루프
            <li>비동기 작업을 처리하고 실행순서를 관리하는 매커니즘</li>
            실행 컨텍스트
            <li>코드가 실행되는 환경을 제공하는 객체</li>
            <li>호이스팅</li>
            <li>LE, record, outer</li>
            <li>컴파일러/인터프리터</li>
            <li>
              일시적 사각지대(Temporal Dead Zone): 선언 이전에 식별자를 참조할
              수 없는 구역
            </li>
            <li>
              스코프 체인(Scope Chain): 식별자를 결정할 때 활용하는 스코프들의
              연결리스트
            </li>
            <li>
              스코프 체이닝(Scope Chaining): 식별자를 결정하기 위해 하는 과정
              자체
            </li>
            클로저
            <li>자신이 선언될 당시의 환경을 기억하는 함수</li>
            <li>스코프: 변수에 접근할 수 있는 범위</li>
            <li>함수는 힙 메모리에 저장</li>
            <li>
              객체 지향 프로그램의 정보 은닉과 캡슐과 같은 효과를 얻을 수 있음
            </li>
            Promise
            <li>콜백 지옥에서 벗어나기</li>
            <li>비동기 처리의 결과를 약속하는 객체</li>
            <li>상태값: pending, fulfilled(성공), rejected(실패)</li>
            <li>성공 => resolve(), 실패 => reject()</li>
            <li>.then, .catch 체이닝</li>
            async, await
            <li>함수가 끝날 때까지 기다린다</li>
            class
            <li>생성자 constructor</li>
            <li>메서드 method()</li>
            <li>
              class 자식 extends 부모: 자식 클래스는 부모 클래스의 메서드 사용
              가능, 반대는 불가능
            </li>
            array
            <li>
              중간에 넣거나 빼기 속도 아주 느림, 메모리 공간 주소 할당, 빈 칸
              생기면 채우는 과정 복잡
            </li>
            <li>만들기(split): 문자열을 배열로</li>
            <li>합치기(join): 배열을 문자열로</li>
            <li>추가(push)</li>
            <li>배열 합치기(concat): const array3 = array1.concat(array2);</li>
            <li>삭제(pop, splice: 원본 배열 바꿈, slice: 새로운 함수 반환)</li>
            <li>반복문(forEach, map: 새로운 배열 반환, 객체 반환 가능)</li>
            <li>
              찾기(find: 객체 검색 가능, indexOf: 없으면 -1, findIndex: 없으면
              -1, includes)
            </li>
            <li>
              정렬(sort: 원본 배열을 바꿈, 콜백함수 없으면 유니코드 기준으로
              정렬)
            </li>
            <li>뒤집기(reverse)</li>
            Map
            <li>객체와 비슷, 객체는 key에 string만 씀</li>
            <li>쓰는 이유? 명시적이다. get, set, has, clear</li>
            <li>객체와 맵은 서로 호환이 된다.</li>
            <li>let map1 = new Map(); map1.set('a', 3); map1.get('a');</li>
            <li>key찾기: map1.has('a')</li>
            <li>내용 지우기: map1.clear();</li>
            Set
            <li>중복을 허용 하지 않음, 키가 없음</li>
            <li>const set1 = new Set(); set1.add(1); set1.has(1);</li>
          </div>
          <h1><a href="#top" name="0704">0704</a></h1>
          <div class="cnts">
            <h3>http</h3>
            TCP
            <li>
              서버와 클라이언트간 신뢰성 있는 데이터 송수신을 위해 만들어진
              프로토콜
            </li>
            UDP
            <li>TCP와 다르게 비연결성 프로토콜</li>
            소켓
            <li>네트워크에서 데이터를 송수신하기 위해 반드시 거치는 연결부</li>
            <li>
              TCP 소켓: 안정적인 데이터 송수신, UDP 소켓: 빠른 전송속도, 일부
              패킷 손실 가능
            </li>
            패킷
            <li>소켓을 통해 송수신하는 데이터 덩어리 한 개</li>
            웹소켓
            <li>실시간 웹 서비스를 제공하기 위해 만들어진 Socket</li>
            <li>Google Docs 등 협업툴의 실시간 공동 편집 기능, 웹 메신저</li>
            socket.io
            <li>
              자바스크립트를 사용해 웹소켓 사용할 때 가장 많이 사용되는
              라이브러리
            </li>
            <li>
              웹소켓을 포함해 웹소켓을 사용하지 못 하는 브라우저에서 사용
              가능하게 구현
            </li>
            <h3>html</h3>
            <li>html 파일 브라우저에 드래그, 드랍</li>
            <h3>cookie</h3>
            <li>refresh token 저장할 object 전역변수</li>
            <li>
              jwt.sign으로 access token(jwt 데이터에 유저 정보 저장: 서버에
              접근할 때 확인용), refresh token 생성(서버에서 인증받은 사용자가
              맞는지 검증용)
            </li>
            <li>refresh token에 유저 정보 저장</li>
            <li>각 토큰 쿠키에 전달</li>
            <li>쿠키에 있는 각 토큰 변수에 담아서 검증 시작</li>
            <li>
              토큰의 존재 유무, jwt.verify 검증(refresh token 없으면 만료,
              access token 없으면 refresh token 재발급)
            </li>
            <li>access token에 유저 정보 없으면 access token 새로 발급</li>
            <li>
              tokenObject[refreshToken] = id; refreshToken의 값이 key, id 값이
              value인 객체 tokenObject
            </li>
            <h3>redis</h3>
            <li>인메모리 데이터 저장소</li>
            <li>
              캐시는 데이터 미리 계산하여 저장, 필요할 때 저장된 데이터 바로
              제공
            </li>
            <li>빠른 응답, DB에 비해 높은 처리량</li>
            <h3>OSI 7계층</h3>
            <li>
              Open Systems Interconnection 7 layer, 네트워크 통신이 일어나는
              과정 7단계
            </li>
            <li>물리 physical: 리피터, 허브, 광케이블</li>
            <li>데이터링크 Data Link: MPLS, Ethernet</li>
            <li>네트워크 Network: IP</li>
            <li>전송 Transport: TCP, UDP</li>
            <li>세션 Session: 통신하는 프로세스/호스트간 연결 유지 SSL, TLS</li>
            <li>표현 presentation: 데이터 포맷</li>
            <li>어플리케이션 Application: HTTP</li>
          </div>
          <h1><a href="#top" name="0705">0705</a></h1>
          <div class="cnts">
            <h3>transaction</h3>
            <li>작업의 완전성 보장, 그룹화</li>
            <li>특정 작업 전부 처리, 전부 실패, 데이터의 일관성 보장</li>
            <li>partial update 방지</li>
            <li>
              ACID 데이터 베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기
              위한 특징
            </li>
            <li>Atomicity 원자성: 여러 작업 묶음</li>
            <li>
              Aonsistency 일관성: 성공시 문제 발생하지 않고 실패시 데이터 유지
            </li>
            <li>
              Isolation 격리성: 중간 상태의 트랜잭션 보거나 변경할 수 없게 구성
              lock
            </li>
            <li>Durability 지속성: 완성된 결과만 저장</li>
            <h3>lock</h3>
            <li>shared locks 공유 락, 읽기 허용/수정 금지, read 전용 락</li>
            <li>exclusive locks 배타락, 읽기,수정 금지, write 전용 락</li>
            <h3>locking level</h3>
            <li>
              global locks 데이터 베이스의 모든 테이블 락(현재 트랜잭션만 사용)
            </li>
            <li>table locks 테이블 동시 수정 불가</li>
            <li>named locks 특정 문자열 점유(금지)</li>
            <li>
              metadata locks 동일한 행 및 데이터 베이스의 객체 동시 수정 금지
            </li>
            <h3>잘못된 lock 설정</h3>
            <li>
              모든 API 동작 중지되는 교착상태(dead lock) 발생, 프로그램 멈춤
            </li>
            <li>
              dead lock여러 테이블 락, 다른 작업 처리 못 하게 점유, 다른 작업
              끝나기를 무한정 기다림(서로가 서로의 리소르 점유)
            </li>
            <h3>isolation level 트랜잭션의 격리 수준</h3>
            <li>동시 처리될 때 다른 트랜잭션에 대한 행위 허용/거부 결정</li>
            <li>
              read uncommited 커밋 되지 않은 읽기 허용(작업중인 데이터 읽음)
            </li>
            <li>read commited 커밋된 읽기만 허용</li>
            <li>
              repeteable 트랜잭션이 완전히 종료될 때가지 락 유지, 데이터 수정
              불가능/삽입 가능 -> 팬텀 읽기 발생(phantom row=삭제된 데이터)
            </li>
            <li>
              serializable 데이터를 읽는 동안 다른 트랜잭션이 읽기/삽입/추가
              불가, 가장 높은 수준의 격리 수준, 동시성 떨어짐
            </li>
            <h3>transaction 흐름</h3>
            <li>트랜잭션 객체 할당</li>
            <li>할당된 객체 각각의 쿼리에 할당</li>
            <li>모든 로직 완료 되었을 때 commit</li>
            <li>작업 실패했을 때 rollback</li>
            <li>sequelize에서 Transaction 객체 구조 분해 할당</li>
            <li>격리 수준 설정</li>
            <h3>UsersHistories</h3>
            <li>
              사용자의 이름을 변경하는 api 구현, 변경된 사용자 이름 정보 logging
              하기 위해
            </li>
            <li>
              사용자의 모든 변경사항, api 호출 내역 등 다양한 정보를 저장하게
              된다면 UUID 사용해 컬럼을 최소화
            </li>
            <h3>Object-Oriented 객체 지향</h3>
            <li>누가 어떤 역할을 할 것인가?</li>
            <li>
              객체지향: 캡슐화, 다형성, 클래스 상속 지원, 데이터 접근
              제한<->절차지향
            </li>
            <li>
              캡슐화 Encapsulation: 정보 은닉, 변경하기 쉬운 객체, 객체와 객체
              사이의 결합도 낮춤
            </li>
            <li>
              상속 Inheritance: 코드 중복 제거, 재사용성 증대, 체계화된 구조
              파악 쉬움, 부모클래스만 수정해 일관성 유지
            </li>
            <li>
              추상화 Abstraction: 객체에서 공통된 특성 파악, 불필요한 부분 제거
            </li>
            <li>
              다형성 Polymorphism: 동일한 메소드 이름, 클래스마다 다르게 구현
            </li>
            <li>
              의존성 Dependency: 어떤 객체가 변경될 때 그 객체에 의존하는 다른
              객체도 함께 변경될 수 있음
            </li>
            <li>결합도 Coupling: 의존성의 정도, 결합도가 높다/낮다</li>
            <li>
              응집도 Cohesion: 자신의 데이터 스스로 처리하는 자율적인 객체는
              응집도 높음
            </li>
            <li>
              목표: 추상화->추상 클래스->인터페이스->다형성, 의존성↓ 결합도↓
              응집도↑
            </li>
            <li>
              클래스의 멤버 변수는 외부에서 직접 접근 불가능, setter/getter로
              변경/조회 가능
            </li>
            <li>
              typescript: javascript는 클래스 멤버 변수 숨길 수 없음, 인터페이스
              없음
            </li>
            <li>
              overriding 오버라이딩: 부모클래스 생성 메서드 -> 자식클래스에서
              새로 생성
            </li>
            <li>
              overloading 오버로딩: 부모클래스 생성 메서드 -> 자식클래스
              파라미터 다르게 새로 생성
            </li>
            <h3>프로그래밍 패러다임</h3>
            구조적 프로그래밍 Structured Programming
            <li>기능 중심 개발, 제어 흐름의 직접적인 전환에 대한 규칙 제시</li>
            객체 지향 프로그래밍 Object-Oriented Programming
            <li>
              현실 세계를 모델링, 제어 흐름의 간접적인 전환에 대한 규칙 제시
            </li>
            <li>데이터, 프로세스가 동일한 모듈 내부에 위치</li>
            <li>최소한의 수정, 개발 시간 최소화</li>
            <li>
              데이터 중심으로 프로그래밍, 덩치는 커져도 일관성 유지하기 좋음
            </li>
            함수형 프로그래밍 Functional Programming
            <li>함수를 중심적으로 개발, 할당문에 대한 규칙 제시</li>
            객체 지향 설계
            <li>
              요구 기능 온전히 수행, 이해하기 쉬운 코드, 변경하기 쉬운 설계(한
              번엔 하나의 클래스만 변경)
            </li>
            <li>캡슐화 -> 의존성 적절히 관리 -> 객체 사이의 결합도 낮춤</li>
            <h3>객체 지향 설계 5원칙 SOLID</h3>
            <li>유지 보수, 확장 쉬운 시스템 만들 때 사용</li>
            SRP 단일 책임의 원칙 Single Responsibility Principle
            <li>적절한 클래스의 크기 제시, 동작하기만 하는 소프트웨어 X</li>
            OCP 개방-폐쇄 원칙 Open-Closed Principle
            <li>
              개체의 행위는 확장, 개체 변경은 안됨 (기존 코드 영향 없이 새로운
              기능, 구성요소 추가 가능)
            </li>
            LSP 리스코프 치환 원칙 Liskov substitution principle
            <li>부모클래스와 자식클래스를 서로 바꿔도 동일한 결과값 도출</li>
            ISP 인터페이스 분리 원칙 Interface segregation principle
            <li>
              사용자가 필요하지 않은 것들에 의존하지 않도록 인터페이스 작게 유지
            </li>
            DIP 의존성 역전 원칙 Dependency Inversion Principle
            <li>
              높은 계층의 모듈은 낮은 계층의 모듈에 의존해선 안됨, 추상화에
              의존해야지 구체화에 의존하면 안 된다
            </li>
          </div>
          <h1><a href="#top" name="0706">0706</a></h1>
          <div class="cnts"></div>
        </div>
      </div>
      <div class="outer-link"></div>
    </main>
    <footer></footer>
  </body>
</html>
